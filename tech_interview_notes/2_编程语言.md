
---

# Intro

---

# 1 C和C++

## 1.1 C和C++基础概念

## 1.2 C++面向对象


**1 构造函数成员初始化列表**

**2 构造函数和析构函数的调用顺序**

**3 关于new和delete**
问: operator new/opeartor delete与new/delete区别

问: malloc/free与new/delete的区别

**4 如何限制栈对象或者堆对象的生成**

**5 成员函数的重载、覆盖(虚函数)、隐藏(重名，无virtual关键字)的比较**

**6 理解is-a和has-a的区别，区分public继承和private继承**

**7 区分接口继承(virtual函数)和实现继承(非virtual函数)**

**8 智能指针**
a. 获得资源后立刻放回进管理对象中，管理对象被销毁或者离开作用域时其析构函数会自动调用，于是资源被释放。可以参考shared_ptr的用法，访问原始对象

b. 如何设计一个auto_ptr智能指针(拷贝构造函数和赋值运算符会使所有权会转移)

**9 尽量以const引用参数代替值参数；返回类型对象时，必须返回新对象时别用引用**
a 解释:
一是为了提高效率，不会发生重复的构造和析构操作并且const防止原始对象发生修改
二是以引用的方式可以避免切片(子类赋值给父类时，父类必须是指针或者引用才不会出现此问题

b 解释:
绝不要返回指针或引用指向一个栈对象或者返回引用指向一个堆对象(必须靠new，但是谁来做delete),因而栈对象和堆对象都不可以。直接用构造函数返回即可；

总结: 返回一个const by-value结果但接受一个reference-to-const实参

**10 继承层次下类转换**
首先明确的是派生类向基类的转换是隐式的，因为派生类包含了基类所有的信息

类型转换函数operator A()或者实现非explicit的构造函数，要避免提供隐式转换

**11 虚函数多态**
a. 虚函数机制
虚函数表vtbl和虚函数表指针Vptrvtbl，要善于画图，静态的数据放在对象外面，非虚函数的成员函数无论stati与否c也放在外面RTTI：vptr的设定和重置都有每一个类的构造函数、复制构造和析构函数自动完成，每个类所管理的type_info信息也由vtbl指出来

一个虚基类子对象只会在继承类中存在一份尸体，不管它在继承体系中出现了多少次

b. 为什么构造函数不能为虚函数
虚函数指不同的继承层次对象产生不同的动作，现在构造函数对象都没产生，何来使用虚函数

c. 为什么基类的析构函数必须为虚函数
防止切片造成的资源释放不全，但注意构造函数和析构函数都不要调用虚函数(按构造顺序和虚函数机制去理解)

d. 哪些不能为虚函数
普通函数、静态成员函数、构造函数、友元函数；（内联成员函数和赋值操作符重载声明为虚函数无意义）

**12 如何讲文件间的编译依赖关系降至最低**
a. 明智的使用Pimpl(指向实现的指针)，真正的接口与实现分离
**Pimpl手法:  以指针指向一个对象，内含有真正数据**

类似于Qt的前置声明方式，使用声明式不用定义式，这种手段称为Handler classes。使得使用者完全与具体定义的细节分离了，并且这些细节的任何修改并不需要客户端重新编译

b. 设计一个接口类
C++中定义了一个特殊的抽象基类，称为Interface class

c. 区分Java中接口和抽象类：http://www.cnblogs.com/kym/archive/2010/10/31/1865836.html

**13 写一个不抛出异常的Swap函数**

**14 写一个String类和含引用技术的String类**

---

# 2 Java

---

# 参考

---
